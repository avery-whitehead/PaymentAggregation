"""
Takes a BPY331 formatted log of payment records, aggregates the total of each
payee and writes it back to the file.

HOW IT WORKS:
    1. The filenames of new files are read from the directory.
    2. A Payment object is created for each record in a file. An account
    reference is made for each Payment object. A mod10 algorithm is used to
    create a checkdigit from the bank sort code, and a mod26 algorithm on the
    first two digits of the bank account number is used to create an A-Z
    character. The first two digits of the bank account number are replaced
    with the A-Z character, and the checkdigit is appended to the end of that.
    3. A primary key is created for each unique combination of account
    reference and building society number.
    4. Each Payment object is assigned to its matching primary key based on
    the value of its account reference and building society number.
    5. For each primary key, the total amount paid for each Payment object
    belonging to it is summed up, and a new Payment object is created.
    6. Each of these new Payment objects is written back to file.

PROCESSES:
    1. load_files() - gets the file names from a directory. Returns a list of
    the file paths for the files.
    2. create_payments() - reads in the files and create a Payment object for
    each record. Returns a list of Payment objects. Calls gen_account_ref() to
    return a string for the account reference.
    3. create_keys() - makes a series of primary keys. Returns a dictionary
    with the primary keys as the keys and an empty list for each value.
    4. assign_keys() - fills the lists in the dictionary values with the
    matching Payment objects. Returns the dictionary from create_keys() but
    with Payment objects filling the empty list.
    5. sum_payments() - goes through each Payment object in each list and
    sums the total of their payment amounts. Creates a new Payment object for
    each key with the same attributes as the old Payment objects, but with the
    sum total attribute replacing the old individual amounts. Returns a list
    of new Payment objects.
    6. write_payments() - writes the new Payment objects to a file in the same
    structure as the original files. Returns a success string about which
    files were written.
"""

import os
import datetime

class Payment(object):
    """
    A payment recording according the BPY331 format. The 'defaults' dict lets
    us use the 'attribute=value' syntax when creating a Payment object.
    """
    def __init__(self, **kwargs: str) -> None:
        self.defaults = {
            'interface_source': '"BEN"',
            'batch_run_id': '"batch_run_id"',
            'posting_ref': '"posting_ref"',
            'account_ref': '"NOT_YET_SET"',
            'payee_type': '"CL"',
            'payee_name': '"payee_name"',
            'payee_address': '"Aggregated DHP UC Payment"',
            'claim_ref': '"claim_ref"',
            'claimant_name': '"Aggregated DHP UC Payment"',
            'claimant_adddress': '"Aggregated DHP UC Payment"',
            'amount': '"amount"',
            'posting_start_date': '"{}"'.format(SYSTIME),
            'posting_end_date': '"{}"'.format(SYSTIME),
            'payment_method': '"BACS"',
            'creditor_account_ref': '""',
            'bank_sort_code': '"bank_sort_code"',
            'bank_account_num': '"bank_account_num"',
            'bank_account_name': '"bank_account_name"',
            'building_society_num': '"building_society_num"',
            'post_office_name': '""',
            'post_office_address': '""',
            'collection_flag': '"N"',
            'document_num': '""',
            'document_type': '""',
            'replacement_flag': '"N"',
            'effective_date': '"{}"'.format(SYSTIME),
            'blank_one': '""',
            'blank_two': '""',
            'document_date': '""'}
        # Fancy kwargs magic for default constructor values
        self.__dict__.update(self.defaults)
        self.__dict__.update(kwargs)

    def set_account_ref(self) -> None:
        """
        Sets the account reference and claim reference of a Payment object
        to the string generated by the call to gen_account_ref()
        """
        sort_code = self.bank_sort_code.replace('"', '').replace(' ', '')
        account_num = self.bank_account_num.replace('"', '').replace(' ', '')
        account_ref = self.gen_account_ref(sort_code, account_num)
        self.account_ref = account_ref
        self.claim_ref = account_ref

    def gen_account_ref(self, sort_code: str, account_num: str) -> str:
        """
        Generates a mod10 (Luhn) algorithm checkdigit from a bank sort code
        and, does a mod26 on the first two digits of the account number and
        uses these values with the account number to create the account
        reference.
        Args:
            sort_code (str): The bank sort code, a six-digit number with three
            pairs of two digits separated by a '-'
            account_num (str): An eight digit number
        Returns:
            (str): The account ref in the format "<first two digits of
            account_num mod26 as A-Z><remaining digits of account_num>
            <sort_code check digit>"
        """
        # Splits up the sort code into its digits
        sort_digits = [
            int(dig) for dig
            in list(sort_code.replace('-', ''))]
        # Multiplies every second element by 2
        doubles = [
            num * 2 if index % 2 != 0 else num for index, num
            in enumerate(sort_digits)]
        # Changes any two-digit numbers into two elements (e.g. [18] tp [1, 8])
        temp = ''.join(str(num) for num in doubles)
        doubles = [int(dig) for dig in temp]
        # Sums the digits and subtracts from the nearest multiple of 10
        checkdig = 10 - sum(doubles) % 10
        if checkdig == 10:
            checkdig = 0
        # mod26 the first two digits of the account number
        mod_digs = int(account_num[:2]) % 26
        if mod_digs == 0:
            mod_char = 'A'
        else:
            mod_char = chr(mod_digs + 64)
        return '"{}{}{}"'.format(mod_char, account_num[2:], str(checkdig))

    def print_payment(self) -> None:
        """
        Formats and prints Payment object line-by-line in the same style as
        the records in the file.
        """
        items = self.__dict__.items()
        for key, value in items:
            if key != 'defaults':
                print(value)
        print()

def load_files(file_dir: str) -> list:
    """
    Gets the names of all the BPY331 formatted files from a directory.
    Args:
        file_dir (str): The directory to search.
    Returns:
        (list): A list of the paths of the files.
    """
    files_list = []
    for _, _, files in os.walk(file_dir):
        for file in files:
            if file.startswith('bpy331_') and file.endswith('.dat'):
                files_list.append('{}/{}'.format(file_dir, file))
    return files_list

def create_payments(filepath: str) -> list:
    """
    Reads a file line-by-line and makes a Payment object for each record in
    the file.
    Args:
        filepath (str): The path of the file to read in.
    Returns:
        (list): A list of Payment objects created from the records in the file.
    """
    payments = []
    with open(filepath) as file:
        records = file.read().splitlines()
    # Each record is 29 lines long, so each loop iteration covers one record
    for i in range(1, len(records), 29):
        payment = Payment(
            batch_run_id = records[i + 1],
            posting_ref = records[i + 2],
            payee_name = records[i + 17],
            amount = records[i + 10],
            bank_sort_code = records[i + 15],
            bank_account_num = records[i + 16],
            bank_account_name = records[i + 17],
            building_society_num = records[i + 18])
        payment.set_account_ref()
        payments.append(payment)
    return payments

def create_keys(payments: list) -> dict:
    """
    Creates a series of primary keys based on each unique combination of
    account reference and building society number in each Payment object.
    Args:
        payments (list): A list of Payment objects used to generate the keys.
    Returns:
        (dict): A dictionary with the keys being the primary keys and the
        values being empty lists, to be filled with the associated Payment
        objects later.
    """
    keys = []
    for payment in payments:
        # Trims the quotation marks and trailing whitespace
        key = '{}/{}'.format(
            payment.account_ref[1:-1],
            payment.building_society_num[1:-2])
        keys.append(key)
    # Sets the default value for each key in the dict to be an empty list
    # Note: doesn't work using fromkeys(); each value refers to the same list
    return {k: [] for k in keys}

def assign_keys(payments: list, keys: dict) -> dict:
    """
    Fills the values for each key with the appropriate Payment objects. Each
    Payment object has an account reference and a building society number,
    which when stripped of quotation marks and whitespace and joined
    together with a forward-slash in between, will equal a key in the dict.
    Args:
        keys (dict): A dictionary of keys and empty lists to be filled with
        Payment objects.
    Returns:
        (dict): The dictionary passed as an argument with Payment objects
        taking the place of the values.
    """
    for payment in payments:
        payment_key = '{}/{}'.format(
            payment.account_ref[1:-1],
            payment.building_society_num[1:-2])
        for key in keys:
            if key == payment_key:
                keys[payment_key].append(payment)
    return keys

def sum_payments(keys_vals: dict) -> list:
    """
    For each key-value pair in the dictionary, sums the total amount paid
    for each Payment object in each value list and creates a single new
    Payment object based on that total amount and the other attributes
    taken from the first Payment object in the list.
    Because each Payment object in the list has the same values, it doesn't
    matter which object we take the attributes from, but some lists only have
    a single Payment object in them, so we take the first.
    Args:
        keys_vals (dict): A dictionary with each Payment object assigned to a
        unique key depending on their attributes. Matching Payment objects
        have the same key.
    Returns:
        (list): A list of newly-aggregated Payment objects, one for each key
        in the dictionary.
    """
    new_payments = []
    for _, payments in keys_vals.items():
        total = 0
        for payment in payments:
            amount = payment.amount.replace('"', '').replace(' ', '')
            total += float(amount)
        # Rounds the total to two decimal places and adds the quotes back
        total = '"{:.2f}"'.format(total)
        new_payment = Payment(
            batch_run_id = payments[0].batch_run_id,
            posting_ref = payments[0].posting_ref,
            account_ref = payments[0].account_ref,
            payee_name = payments[0].payee_name,
            claim_ref = payments[0].claim_ref,
            amount = total,
            bank_sort_code = payments[0].bank_sort_code,
            bank_account_num = payments[0].bank_account_num,
            bank_account_name = payments[0].bank_account_name,
            building_society_num = payments[0].building_society_num)
        new_payments.append(new_payment)
    return new_payments

def write_payments(filepath: str, new_payments: list) -> str:
    """
    Writes a list of Payment objects to a file in the same format as the file they
    were read from.
    Args:
        filepath (str): The path of the file to write to (the same as the
        file we read from in load_files())
        new_payments (list): A list of Payment objects to write to file
    Returns:
        (str): A string indicating the file written to and the amount of
        Payment objects in the file
    """
    count = 0
    new_path = '{}.new'.format(filepath[:-4])
    # Gets the header from the original file
    with open(filepath, 'r') as read:
        header = read.read().splitlines()[0]
    with open(new_path, 'w') as write:
        write.write('{}\n'.format(header))
        for payment in new_payments:
            for key, value in payment.__dict__.items():
                if key != 'defaults':
                    write.write('{}\n'.format(value))
            count += 1
            print('Written {}/{} payments to {}'.format(
                count, len(new_payments), new_path))
    return 'Successfully written {}/{} payments to {}'.format(
        count, len(new_payments), new_path)



if __name__ == '__main__':
    SYSTIME = datetime.date.today().strftime('%d-%b-%Y').upper()
    files = load_files('./data')
    for f in files:
        payments = create_payments(f)
        keys = create_keys(payments)
        keys_vals = assign_keys(payments, keys)
        new_payments = sum_payments(keys_vals)
        print(write_payments(f, new_payments))
